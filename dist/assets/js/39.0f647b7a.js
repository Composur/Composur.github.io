(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{413:function(e,s,t){"use strict";t.r(s);var o=t(33),a=Object(o.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"module-的语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#module-的语法"}},[e._v("#")]),e._v(" Module 的语法")]),e._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),t("blockquote",[t("p",[e._v("写在前面，计算机语言的发展，机器语言--汇编语言--低级语言（面向过程）--高级语言（面向对象）--系统化模块--框架--API")])]),e._v(" "),t("h4",{attrs:{id:"es6之前"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6之前"}},[e._v("#")]),e._v(" es6之前")]),e._v(" "),t("ul",[t("li",[e._v("脚本变多时，需要手动管理")]),e._v(" "),t("li",[e._v("不同逻辑脚本间的调用需要用到全局变量。")]),e._v(" "),t("li",[e._v("没有HTML就没法运行了，没地方写script标签")]),e._v(" "),t("li",[e._v("没有模块(在HTML中借助"),t("code",[e._v("script")]),e._v("标签执行"),t("code",[e._v("JavaScript")]),e._v(")--CMD（同步）--AMD（异步）--es6")])]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("AMD")]),e._v("规范:全称”Asynchronous Module Definition”，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库"),t("code",[e._v("Require")]),e._v("JS实现的就是AMD规范。CommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。用于服务器端。"),t("br")])]),e._v(" "),t("ul",[t("li",[e._v("CommonJS 模块就是对象，输入时必须查找对象属性。代码运行时加载，输出的值是值得拷贝")]),e._v(" "),t("li",[e._v("依赖前置，提前执行!")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let { stat, exists, readFile } = require('fs'); //只有先全部加载`fs`这个方法才能在这个对象上读取这个三个方法\n")])])]),t("h4",{attrs:{id:"es6中的module（需要进行编译，在浏览器不能够直接运行）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6中的module（需要进行编译，在浏览器不能够直接运行）"}},[e._v("#")]),e._v(" es6中的module（需要进行编译，在浏览器不能够直接运行）")]),e._v(" "),t("blockquote",[t("p",[e._v("ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。输入的是值的引用")])]),e._v(" "),t("ul",[t("li",[e._v("这种加载称为“编译时加载”或者静态加载，效率更高")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ES6模块\nimport { stat, exists, readFile } from 'fs';  //从`fs`模块加载3个方法不用全部加载\n")])])]),t("h4",{attrs:{id:"export"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#export"}},[e._v("#")]),e._v(" export")]),e._v(" "),t("blockquote",[t("p",[e._v("每个module都是一个独立的文件，该文件类的所有内容外部都无法获取,export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。")])]),e._v(" "),t("ol",[t("li",[t("p",[e._v("写法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export const name='haha'\n\n//也可以\nname='haha'\nsex='male'\nexport {name,sex} //可以接受多个属性\n\n//输出变量和类\n\nexport function fn(){}\n\n")])])])]),e._v(" "),t("li",[t("p",[e._v("export 输出的变量是有名字的，可以使用as替换")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function fn1(){}\n\nexport {fn1 as fn2}\n\n")])])])]),e._v(" "),t("li",[t("p",[e._v("默认成员")]),e._v(" "),t("p",[e._v("export default")])])]),e._v(" "),t("h4",{attrs:{id:"import"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#import"}},[e._v("#")]),e._v(" import")]),e._v(" "),t("p",[t("code",[e._v("import 'fs'")]),e._v(" 这样会加载所有")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\bimport {xx,xxx} form 'xxxxx'\n")])])]),t("p",[t("code",[e._v("import")]),e._v(" 导入的时候需要知道\b要导入的方法名称")]),e._v(" "),t("p",[e._v("如果\b\b使用了 "),t("code",[e._v("export default")]),e._v(" 的默认输出，我们 "),t("code",[e._v("import")]),e._v(" 的时候可以用任意的名字")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export.js\n\nexport default function fn(){} //一个模块只能有一个默认输出，还是可以通过export 正常导出其它函数，import {xx}通过指定名称正常导入\n\n\nimport.js \n\nimport foo from 'export.js' //import时候不能使用大括号\n\n")])])]),t("h4",{attrs:{id:"node-中-commonjs-规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-中-commonjs-规范"}},[e._v("#")]),e._v(" Node 中 CommonJS 规范")]),e._v(" "),t("blockquote",[t("p",[e._v("C\bommonJS 是一个很大的规范 Node 和浏览器只是借用了它的一部分精华")])]),e._v(" "),t("p",[t("em",[e._v("先来Node环境运行的结果：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# a.js\n\nconsole.log('我是a.js')\n\n")])])]),t("p",[t("em",[e._v("无引用的情况：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# b.js\n\nconst lib = require('./a')\nconsole.log('我是b.js')\n\n# 运行b.js\n\n我是a.js\n我是b.js\n")])])]),t("p",[t("em",[e._v("有引用的情况：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# b.js\n\nconst lib = require('./a')\nconsole.log('我是b.js',lib)\n\n# 运行b.js\n\n我是a.js\n我是b.js {} //得到一个空对象\n\n")])])]),t("p",[t("em",[e._v("有 "),t("code",[e._v("exports")]),e._v(" 情况，通过 exports 定义模块的输出：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# a.js\n\nexports.hello='world!' // 这里可以挂载合法的数据类型，对象、字符串、函数等\nconsole.log('我是a.js')\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# b.js\n\nconst lib = require('./a')\nconsole.log('我是b.js',lib)\n\n# 运行b.js\n\n我是a.js\n我是b.js { hello: 'world!' } //得到一个含有 key 的对象 `key` 就是挂载到 `exports` 上的属性名\n\n")])])]),t("p",[t("em",[e._v("b.js require 的引用和 a.js exports 的引用是不是同一个引用？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# a.js\n\nexports.hello='world!'\nconsole.log('我是a.js')\nsetTimeout(()=>{\n  console.log(exports)\n},1000)\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# b.js\n\nconst lib = require('./a')\nconsole.log('我是b.js',lib)\nlib.addNewProperty = '我是b.js中新增加的属性'\n\n# 运行b.js\n\n我是a.js\n我是b.js { hello: 'world!' }\n\n# 一秒后输出 说明\b  exports 导出的引用和 require 得到的引用是同一个引用\n{ hello: 'world!', addNewProperty: '我是b.js中新增加的属性' } \n\n")])])]),t("p",[t("em",[e._v("如果直接导出一个函数该怎么办？ exports.function?")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("a.js\n\nexports.hello='world!'\n\nconsole.log('我是a.js')\n\nmodule.exports = function test(){\n  console.log('我是a.js导出的function')\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("b.js\n\nconst lib = require('./a')\nconsole.log('我是b.js',lib)\nlib.addNewProperty = '我是b.js中新增加的属性'\nconsole.log(lib.hello)\nconsole.log(lib)\n\n# 运行b.js\n\n我是a.js\n我是b.js function test(){\n  console.log('我是a.js导出的function')\n}\nundefined // 拿不到 exports 的引用 \n\n// addNewProperty 挂载到了 module.exports 上\n{ [Function: test] addNewProperty: '我是b.js中新增加的属性' } // module.exports 会覆盖 exports 的内容 \n\n")])])]),t("blockquote",[t("p",[t("code",[e._v("Node 中 ES6 模块和 CommonJS 采用各自的加载方案。")])])]),e._v(" "),t("p",[t("code",[e._v("CommonJS")]),e._v(" 模块的输出都定义在 "),t("code",[e._v("module.exports")]),e._v(" 这个属性上面。"),t("code",[e._v("Node")]),e._v(" 的 "),t("code",[e._v("import")]),e._v(" 命令加载 "),t("code",[e._v("CommonJS")]),e._v(" 模块，"),t("code",[e._v("Node")]),e._v(" 会自动将"),t("code",[e._v("module.exports")]),e._v(" 属性当作模块的默认输出，即等同于 "),t("code",[e._v("export default xxx")])]),e._v(" "),t("p",[e._v("前端可以借助 "),t("code",[e._v("Webpack")]),e._v(" 利用 "),t("code",[e._v("CommonJS")]),e._v(" 的规范书写代码，"),t("code",[e._v("Webpack")]),e._v(" 会把所有的 "),t("code",[e._v("CommonJS")]),e._v(" 分析一遍然后生成一个大的 "),t("code",[e._v("js")]),e._v(",所有的文件成为一个对象{"),t("code",[e._v("./index.js:(function(modeule,exports,__webpack_require__){文件内容}}),./xxx.js:(function(modeule,exports){文件内容}})")]),e._v(" 通过这种形式为每个文件创建了一个作用域。")]),e._v(" "),t("ul",[t("li",[e._v("CommonJS"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// a.js\nmodule.exports = {\n    foo: 'hello',\n    bar: 'world'\n};\n\n// 等同于\nexport default {\n    foo: 'hello',\n    bar: 'world'\n};\n")])])])])]),e._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("ul",[t("li",[e._v("改变 "),t("code",[e._v("require")]),e._v(" 的对象原对象也会受影响（值引用）")]),e._v(" "),t("li",[t("code",[e._v("exports")]),e._v(" 的 "),t("code",[e._v("require")]),e._v(" 的 "),t("code",[e._v("js")]),e._v(" 默认的是一个空对象，对象里面可以有函数")]),e._v(" "),t("li",[t("code",[e._v("exports")]),e._v(" 通过 "),t("code",[e._v("exports.xx")]),e._v(" 导出对象，所有的导出都挂载"),t("code",[e._v("exports")]),e._v("这个对象上，"),t("code",[e._v("require")]),e._v("输入默认的是一个空对象，通过这种方式定义一个对象的输出")]),e._v(" "),t("li",[t("code",[e._v("modules.exports")]),e._v("可以直接导出一个函数")]),e._v(" "),t("li",[t("code",[e._v("exports")]),e._v("和 "),t("code",[e._v("module.exports")]),e._v("同时存在时只会导出 "),t("code",[e._v("module.exports")]),e._v("的内容，会覆盖"),t("code",[e._v("exports")])]),e._v(" "),t("li",[t("code",[e._v("import")]),e._v(" 输出的是值得引用（复制一份地址）")])])])}),[],!1,null,null,null);s.default=a.exports}}]);
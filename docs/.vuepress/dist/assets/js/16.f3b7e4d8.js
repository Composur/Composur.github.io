(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{370:function(e,t,r){"use strict";r.r(t);var a=r(33),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"react、vue中的key的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react、vue中的key的作用"}},[e._v("#")]),e._v(" React、Vue中的key的作用")]),e._v(" "),r("p",[e._v("没有key的时候")]),e._v(" "),r("blockquote",[r("p",[e._v("当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素,"),r("code",[e._v("不带key时节点能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM文本内容而不是移除/添加节点，这就是文档中所说的“刻意依赖默认行为以获取性能上的提升”")]),e._v("。")])]),e._v(" "),r("hr"),e._v(" "),r("p",[e._v("有key时")]),e._v(" "),r("ul",[r("li",[e._v("key的作用就是更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。")]),e._v(" "),r("li",[e._v("key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。")])]),e._v(" "),r("h4",{attrs:{id:"react中的key"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react中的key"}},[e._v("#")]),e._v(" react中的key")]),e._v(" "),r("ul",[r("li",[e._v("react中的key，添加给被foreach 或map（for...of） 或for循环直接控制的元素")])])])}),[],!1,null,null,null);t.default=v.exports}}]);
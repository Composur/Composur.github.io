(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{370:function(t,n,a){"use strict";a.r(n);var e=a(33),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"防抖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#防抖"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),a("blockquote",[a("p",[t._v("防抖就是你尽管去触发事件，但我就是在你给定的时间到后才执行，如果在你给的时间内你又触发了时间那么重新计时，在你给定的时间到后才执行,在规定的时间内只执行一次")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function debounce(func, wait) {\n    var timeout;\n    return function () {\n        clearTimeout(timeout)\n        timeout = setTimeout(func, wait);\n    }\n}\n")])])]),a("h3",{attrs:{id:"节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),a("blockquote",[a("p",[t._v("如果你持续触发事件，每隔一段时间，只执行一次事件。关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。")])]),t._v(" "),a("ul",[a("li",[t._v("事件触发的时候取到当前时间")]),t._v(" "),a("li",[t._v("然后减去之前时间戳（第一次的时候为0）")]),t._v(" "),a("li",[t._v("如果大于等待时间就执行")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function throttle(func,wait){\n    var now=+new Date()\n    var previous=0\n    var _this=this\n    var args=arguments\n    if(now-previous>wait){ //在特定的时间间隔（wait）一直执行\n        func.apply(_this,args)\n        previous=now\n    }\n}\n\n//调用\n\n$ele.onmousemove=throttle(func,wait)\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);
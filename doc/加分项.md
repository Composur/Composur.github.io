### 函数式编程

> 简单说，"函数式编程"是一种["编程范式"](http://en.wikipedia.org/wiki/Programming_paradigm)（programming paradigm），也就是如何编写程序的方法论。
>
> 它属于["结构化编程"](http://en.wikipedia.org/wiki/Structured_programming)的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。

##### 1. 函数编程的特点

+ 函数是’一等公民‘
  + 意思是与其它基本类型一样，处于平等的地位。
    + 可以赋值给其它参数
    + 也可以作为参数，传入另一个函数
    + 还可以作为函数的返回值

+ **只用"表达式"，不用"语句"**
  + 表达式有返回值，语句么有。
+  **没有"副作用"**
  + 副作用
    + 指函数内部与外部的互动：例如改变全局变量的值
  + 没有副作用
    + 函数要保持独立，所有的功能就是一个返回值，没有其它行为，尤其是不可以修改函数外部的其它变量的值。
+ 引用透明，只依赖输入的参数。

##### 2. 函数式编程的好处

+ 代码简洁，减少了代码的重复，开发速度快。

+ 接近自然语言，便于理解。

  ```js
  [].concat([1,2,3])
  ```

##### 3. 方便管理，可移植性高。

##### 4. js 单线程，每个线程相互独立。不存在锁线程。

##### 5. 代码可以热升级。



  





###  跨平台

flutter、react-native、weex、electron

#### 混合app交互

android和h5的交互？细节和ios有什么不同？

我们得明白，jsBridge是如何做到h5和原生应用的交互？

### FileReader

> `**FileReader**` 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 或 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象指定要读取的文件或数据。

在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程

```js
// /public/hash.js
self.importScripts("/spark-md5.min.js"); // 导入脚本

// 根据文件的内容生成文件 hash 就算修改用户名依旧可以判断是否是同一个文件，hash 值是唯一的
self.onmessage = e => {
  const { fileChunkList } = e.data;
  const spark = new self.SparkMD5.ArrayBuffer();
  let percentage = 0;
  let count = 0;
  const loadNext = index => {
    const reader = new FileReader();
    reader.readAsArrayBuffer(fileChunkList[index].file);
    reader.onload = e => {
      count++;
      spark.append(e.target.result);
      if (count === fileChunkList.length) {
        self.postMessage({
          percentage: 100,
          hash: spark.end()
        });
        self.close();
      } else {
        percentage += 100 / fileChunkList.length;
        self.postMessage({
          percentage
        });
        // 递归计算下一个切片
        loadNext(count);
      }
    };
  };
  loadNext(0);
};
```




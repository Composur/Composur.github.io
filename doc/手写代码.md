### 1. 实现一个Promise

+ "promise" 是一个对象或者函数，该对象或者函数有一个 then 方法，一个promise必须有3个状态，pending，fulfilled(resolved)，rejected当处于pending状态的时候，可以转移到fulfilled(resolved) 或者 rejected 状态。当处于 fulfilled(resolved)  状态或者rejected 状态的时候，就不可变。
+ "value" 是 promise 状态成功时的值
+ "reason" 是 promise 状态失败时的值

```javascript
function myPromise(constructor){
    let self=this;
    self.status="pending" //定义状态改变前的初始状态
    self.value=undefined;//定义状态为resolved的时候的状态
    self.reason=undefined;//定义状态为rejected的时候的状态
    function resolve(value){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.value=value;
          self.status="resolved";
       }
    }
    function reject(reason){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.reason=reason;
          self.status="rejected";
       }
    }
    //捕获构造异常
    try{
       constructor(resolve,reject);
    }catch(e){
       reject(e);
    }
}
myPromise.prototype.then=function(onFullfilled,onRejected){
   let self=this;
   switch(self.status){
      case "resolved":
        onFullfilled(self.value);
        break;
      case "rejected":
        onRejected(self.reason);
        break;
      default:       
   }
}

var p=new myPromise(function(resolve,reject){resolve(1)});
console.log(p)
p.then(function(x){console.log(x)})
```

### 2. 实现 call、apply、bind

#### 2.1 call、apply

+  call 和 apply，都是在使用（使用即执行）的时候改变作作用域，第一个参数都表示作用域，一旦改变作用域函数就执行了。
  + call 从第二个参数开始表示传递参数。
  +  apply 第二个参数是数组。

实现思路

```js
var obj={
    value:1
}
function foo(num){
     console.log(this.value)
     return this.value
}
foo.call( )  //call改变了this的指向 指向了obj

// 实现一个call 

var obj={
    value:1,  //思路：1.给要call的this值添加一个属性foo
    foo:function(){
        console.log(this.value)
    }
}

obj.foo() //2.执行

delete obj.foo //3.删除添加的属性
```

##### 2.1.1 实现 call , apply

```js
Function.prototype.call2 = function (context = window) {
  // call、apply 都是立即执行的 返回执行的结果

  // 指定 this 
  context.fn = this

  // 截取参数
  let args = [...arguments].slice(1)

  // 调用函数
  const result = context.fn(...args)
  
  // 删除添加的属性
  delete context.fn
  return result
}

Function.prototype.apply2 = function (context = window) {
  context.fn = this
  let result;
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  // 调用函数
  delete context.fn
  return result
}
```



#### 2.2 bind 的实现

不难看出，bind 返回了一个函数，在执行的时候改变了这个函数的作用域。

```js
this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 'this' 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
```

##### 2.2.1  利用 call 和 apply 实现

```javascript
Function.prototype.bind2 = function (scope) {
  let args = [...arguments].slice(1)
  let fn = this
  return function () {
   return fn.apply(scope, args.concat(...arguments))
  }
}
```



### 3. 实现一个 JSON.stringify()

+ Boolean | Number| String 类型会自动转换成对应的原始值。
+  undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。
+ 不可枚举的属性会被忽略
+  如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略

```js
/**
 * @description 实现一个 JSON.stringify()
 * @param {Object} obj 
 */
const stringify = (obj) => {
  const type = typeof obj
  if (type !== 'object') {
    if (/string|boolean|function/.test(type)) {
      obj = `"${obj}"`
    }
    return String(obj)
  } else {
    let json = []
    let arr = Array.isArray(obj)
    for (let k in obj) {
      const type = typeof obj[k]
      let v = obj[k]
      if (/string|undefined|function/.test(type)) {
        v = `"${v}"`
      } else if (type === 'object') {
        v = stringify(v)
      }
      json.push((arr ? "" : '"' + k + '":') + String(v));
    }
    return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}")
  }
}
const obj = {
  a: {
    aa: 'aa',
  },
  b: undefined,
  c: Symbol('c'),
  d: this.a,
  c:1
}
const log = console.log.bind(console)
log(stringify(obj)) //{"a":{"aa":"aa"},"b":"undefined","c":1,"d":"undefined"}
log(JSON.stringify(obj)) //{"a":{"aa":"aa"},"c":1}
```

### 4. 实现一个 JSON.parse

+ eval

  `**eval()**` 函数会将传入的字符串当做 JavaScript 代码进行执行。

  ```js
  const parse = function(obj){
    return eval('(' + obj + ')');
  }
  console.log(parse(JSON.stringify({a:1,b:{a:1}}))); //{ a: 1, b: { a: 1 } }
  ```

  

+ Function 

  **`Function` 构造函数**创建一个新的 `Function` **对象**。直接调用此构造函数可用动态创建函数

  ```js
  const sum = new Function('a', 'b', 'return a + b');
  
  console.log(sum(2, 6));
  // expected output: 8
  
  
  const parseFunc = function(str){
    return  (new Function('str','return'+ str))()
  }
  
  console.log(parseFunc(JSON.stringify({a:1,b:{a:1}})));//{ a: 1, b: { a: 1 } }
  ```

  

### 5. 实现一个继承

#### 5.1 原型链继承

```js
function Parent(name) {
  this.name = name
  this.arr = [1,2,3]
}
Parent.prototype.say = function () {
  console.log('p',this.name)
}

function Child(name) {
  this.name = name
}
// 原型链继承
Child.prototype = new Parent()

var c = new Child('子')
var s = new Child('子')

// 共享实例
c.arr.push(4)
console.log(c.arr) // [ 1, 2, 3, 4 ]
console.log(s.arr) // [ 1, 2, 3, 4 ]

```

存在的问题：共享实例；不能像父级传递参数。

#### 5.2 混合继承，借助构造函数继承

```js
function Parent(name) {
  this.name = name
  this.arr = [1,2,3]
}
Parent.prototype.say = function () {
  console.log('p',this.name)
}

function Child(name) {
  // 向父级传递参数
  Parent.call(this) // 第一次实例化
  this.name = name
}
// 原型链继承
Child.prototype = new Parent() // 第二次实例化

var c = new Child('子')
var s = new Child('子')

// 不共享实例
c.arr.push(4)
console.log(c.arr) // [ 1, 2, 3, 4 ]
console.log(s.arr) // [ 1, 2, 3 ]
```

问题：实例化了两次父类。

#### 5.3 原型继承

```js
function object(o){
	function F(){}
	F.prototype = o.prototype;
	return new F();
}
// 提换 new Parent()
Child.prototype = object(Parent)
```




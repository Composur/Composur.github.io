### 实现一个Promise
```javascript
function myPromise(constructor){
    let self=this;
    self.status="pending" //定义状态改变前的初始状态
    self.value=undefined;//定义状态为resolved的时候的状态
    self.reason=undefined;//定义状态为rejected的时候的状态
    function resolve(value){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.value=value;
          self.status="resolved";
       }
    }
    function reject(reason){
        //两个==="pending"，保证了状态的改变是不可逆的
       if(self.status==="pending"){
          self.reason=reason;
          self.status="rejected";
       }
    }
    //捕获构造异常
    try{
       constructor(resolve,reject);
    }catch(e){
       reject(e);
    }
}
myPromise.prototype.then=function(onFullfilled,onRejected){
   let self=this;
   switch(self.status){
      case "resolved":
        onFullfilled(self.value);
        break;
      case "rejected":
        onRejected(self.reason);
        break;
      default:       
   }
}

var p=new myPromise(function(resolve,reject){resolve(1)});
console.log(p)
p.then(function(x){console.log(x)})
```

### 实现 call、apply、bind

#### call、apply

+  call 和 apply，都是在使用（使用即执行）的时候改变作作用域，第一个参数都表示作用域，一旦改变作用域函数就执行了。
  + call 从第二个参数开始表示传递参数。
  +  apply 第二个参数是数组。

实现思路

```js
var obj={
    value:1
}
function foo(num){
     console.log(this.value)
     return this.value
}
foo.call( )  //call改变了this的指向 指向了obj

// 实现一个call 

var obj={
    value:1,  //思路：1.给要call的this值添加一个属性foo
    foo:function(){
        console.log(this.value)
    }
}

obj.foo() //2.执行

delete obj.foo //3.删除添加的属性
```

实现 call , apply

```js
Function.prototype.call2 = function (context = window) {
  // call、apply 都是立即执行的 返回执行的结果

  // 指定 this 
  context.fn = this

  // 截取参数
  let args = [...arguments].slice(1)

  // 调用函数
  const result = context.fn(...args)
  
  // 删除添加的属性
  delete context.fn
  return result
}

Function.prototype.apply2 = function (context = window) {
  context.fn = this
  let result;
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  // 调用函数
  delete context.fn
  return result
}
```



#### bind 的实现

不难看出，bind 返回了一个函数，在执行的时候改变了这个函数的作用域。

```js
this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回 9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 'this' 绑定到 module 对象
// 新手可能会将全局变量 x 与 module 的属性 x 混淆
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
```

利用 call 和 apply 

```javascript
Function.prototype.bind2 = function (scope) {
  let args = [...arguments].slice(1)
  let fn = this
  return function () {
   return fn.apply(scope, args.concat(...arguments))
  }
}
```




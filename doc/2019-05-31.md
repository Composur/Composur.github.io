## Module 的语法

### 概述

> 写在前面，计算机语言的发展，机器语言--汇编语言--低级语言（面向过程）--高级语言（面向对象）--系统化模块--框架--API

#### es6之前

+ 脚本变多时，需要手动管理
+ 不同逻辑脚本间的调用需要用到全局变量。
+ 没有HTML就没法运行了，没地方写script标签
+ 没有模块(在HTML中借助`script`标签执行`JavaScript`)--CMD（同步）--AMD（异步）--es6

>`AMD`规范:全称”Asynchronous Module Definition”，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库`Require`JS实现的就是AMD规范。CommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。用于服务器端。<br/>

+ CommonJS 模块就是对象，输入时必须查找对象属性。代码运行时加载，输出的值是值得拷贝
+ 依赖前置，提前执行!
```
let { stat, exists, readFile } = require('fs'); //只有先全部加载`fs`这个方法才能在这个对象上读取这个三个方法
```

#### es6中的module（需要进行编译，在浏览器不能够直接运行）

> ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。输入的是值的引用

+ 这种加载称为“编译时加载”或者静态加载，效率更高

```
// ES6模块
import { stat, exists, readFile } from 'fs';  //从`fs`模块加载3个方法不用全部加载
```

#### export

>每个module都是一个独立的文件，该文件类的所有内容外部都无法获取,export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

1. 写法

    ```
    export const name='haha'

    //也可以
    name='haha'
    sex='male'
    export {name,sex} //可以接受多个属性

    //输出变量和类

    export function fn(){}

    ```

2. export 输出的变量是有名字的，可以使用as替换

    ```
    function fn1(){}

    export {fn1 as fn2}

    ```

3. 默认成员

    export default 

#### import

`import 'fs'` 这样会加载所有

```
import {xx,xxx} form 'xxxxx'
```
`import` 导入的时候需要知道要导入的方法名称

如果使用了 `export default` 的默认输出，我们 `import` 的时候可以用任意的名字

```
export.js

export default function fn(){} //一个模块只能有一个默认输出，还是可以通过export 正常导出其它函数，import {xx}通过指定名称正常导入


import.js 

import foo from 'export.js' //import时候不能使用大括号

```


#### Node 加载 CMD 规范

>`Node将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。`

`CommonJS` 模块的输出都定义在 `module.exports` 这个属性上面。`Node` 的 `import` 命令加载 `CommonJS` 模块，`Node` 会自动将`module.exports` 属性当作模块的默认输出，即等同于 `export default xxx`

前端可以借助 `Webpack` 利用 `CommonJS` 的规范书写代码，`Webpack` 会把所有的 `CommonJS` 分析一遍然后生成一个大的 `js`,所有的文件成为一个对象{`文件名`：`function(){文件内容}}` 通过这种形式为每个文件创建了一个作用域。

+ CommonJS
    ```
    // a.js
    module.exports = {
        foo: 'hello',
        bar: 'world'
    };

    // 等同于
    export default {
        foo: 'hello',
        bar: 'world'
    };
    ```

### 总结

+ 改变 `require` 的对象原对象也会受影响（值引用）
+ `exports` 的 `require` 的 `js` 默认的是一个空对象，对象里面可以有函数
+ `exports` 通过 `exports.xx` 导出对象，所有的导出都挂载`exports`这个对象上，`require`输入默认的是一个空对象，通过这种方式定义一个对象的输出
+ `modules.exports`可以直接导出一个函数
+ `exports`和 `module.exports`同时存在时只会导出 `module.exports`的内容，会覆盖`exports`
+ `import` 输出的是值得引用（复制一份地址） 


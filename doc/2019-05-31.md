## Module 的语法

### 概述

> 写在前面，计算机语言的发展，机器语言--汇编语言--低级语言（面向过程）--高级语言（面向对象）--系统化模块--框架--API

#### es6之前

+ 脚本变多时，需要手动管理
+ 不同逻辑脚本间的调用需要用到全局变量。
+ 没有HTML就没法运行了，没地方写script标签
+ 没有模块(在HTML中借助`script`标签执行`JavaScript`)--CMD（同步）--AMD（异步）--es6

>`AMD`规范:全称”Asynchronous Module Definition”，称为 异步模块加载规范 。一般应用在浏览器端。流行的浏览器端异步加载库RequireJS实现的就是AMD规范。CommonJS: 称为同步模块加载规范，也就是说，只有加载完成，才能执行后面的操作。用于服务器端。<br/>

+ CommonJS 模块就是对象，输入时必须查找对象属性。代码运行时加载，输出的值是值得拷贝
+ 依赖前置，提前执行!
```
let { stat, exists, readFile } = require('fs'); //只有先全部加载`fs`这个方法才能在这个对象上读取这个三个方法
```

#### es6中的module（需要进行编译，在浏览器不能够直接运行）

> ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。输入的是值的引用

+ 这种加载称为“编译时加载”或者静态加载，效率更高

```
// ES6模块
import { stat, exists, readFile } from 'fs';  //从`fs`模块加载3个方法不用全部加载
```

#### export

>每个module都是一个独立的文件，该文件类的所有内容外部都无法获取,export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。

1. 写法

    ```
    export const name='haha'

    //也可以
    name='haha'
    sex='male'
    export {name,sex} //可以接受多个属性

    //输出变量和类

    export function fn(){}

    ```

2. export 输出的变量是有名字的，可以使用as替换

    ```
    function fn1(){}

    export {fn1 as fn2}

    ```

3. 默认成员

    export default 
#### import

import 'fs' 这样会加载所有

import {xx,xxx} form 'xxxxx'

import 导入的时候需要知道要导入的方法名称

如果使用了export default 的默认输出，我们import的时候可以用任意的名字

```
export.js

export default function fn(){} //一个模块只能有一个默认输出，还是可以通过export 正常导出其它函数，import {xx}通过指定名称正常导入


import.js 

import foo from 'export.js' //import时候不能使用大括号

```


#### Node 加载 CMD规范

`Node将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。`

CommonJS 模块的输出都定义在module.exports这个属性上面。Node 的import命令加载 CommonJS 模块，Node 会自动将module.exports属性，当作模块的默认输出，即等同于export default xxx

前端可以借助webpack利用CommonJS的规范书写代码，webpack会把所有的CommonJS分析一遍然后生成一个大的js,所有的文件成为一个对象{`文件名`：`function(){文件内容}}`通过这种形式为每个文件创建了一个作用域。
+ commonJS
    ```
    // a.js
    module.exports = {
        foo: 'hello',
        bar: 'world'
    };

    // 等同于
    export default {
        foo: 'hello',
        bar: 'world'
    };
    ```
+ 改变require的对象原对象也会受影响 
+ exports的require的js默认的是一个空对象，对象里面可以有函数
+ exports通过exports.xx导出对象，所有的导出都挂载exports这个对象上，require默认的是一个空对象，通过这种方式定义一个对象的输出
+ modules.exports可以直接导出一个函数
+ exports和module.exports同时存在时只会导出module.exports的内容，会覆盖exports
+ import输出的是值得引用（复制一份地址） 

